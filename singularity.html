<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singularity Event</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 5px 0;
            opacity: 0.8;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .stat {
            font-size: 0.9rem;
            color: #aaa;
            margin-bottom: 2px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            letter-spacing: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }
    </style>
    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="ui-layer">
        <h1>SINGULARITY_SIMULATION // v1.0</h1>
        <div class="stat">ENTROPY: <span id="entropy">0.0000</span></div>
        <div class="stat">INTELLIGENCE_DENSITY: <span id="density">10^0</span></div>
        <div class="stat">EVENT_HORIZON_STABILITY: <span id="stability">100%</span></div>
    </div>
    <div id="loading" class="loading">INITIALIZING CORE...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0,
            particleCount: 15000,
            coreSize: 2,
            colors: {
                core: 0x000000,
                accretionInner: 0xffaa00,
                accretionOuter: 0x0044ff,
                star: 0xffffff
            }
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const renderScene = new RenderPass(scene, camera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 4;
        controls.maxDistance = 20;


        // --- TEXTURES ---
        const textureLoader = new THREE.TextureLoader();
        // Create a simple circular particle texture programmatically
        const createParticleTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const center = 16;
            const gradient = context.createRadialGradient(center, center, 0, center, center, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        };
        const particleTexture = createParticleTexture();

        // --- SHADERS ---

        // 1. Accretion Disk Shader
        const diskVertexShader = `
            uniform float time;
            attribute float size;
            attribute float speed;
            attribute float offset;
            varying vec3 vColor;
            
            void main() {
                vColor = color;
                vec3 pos = position;
                
                // Swirling animation based on distance from center
                float dist = length(pos.xz);
                float angle = atan(pos.z, pos.x);
                
                // Closer particles move faster
                float velocity = speed * (100.0 / (dist * dist + 0.1)); 
                float currentAngle = angle + (time * velocity + offset);
                
                pos.x = cos(currentAngle) * dist;
                pos.z = sin(currentAngle) * dist;
                
                // Slight vertical wobble
                pos.y += sin(time * 2.0 + dist) * 0.1 * (dist / 10.0);

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const diskFragmentShader = `
            uniform sampler2D pointTexture;
            varying vec3 vColor;
            
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                if (gl_FragColor.a < 0.1) discard;
            }
        `;

        // 2. Event Horizon (Black Hole) Shader
        const horizonVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                vViewPosition = -mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const horizonFragmentShader = `
            uniform float time;
            uniform vec3 glowColor;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            
            void main() {
                // Fresnel effect for the edge glow
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);
                float fresnel = dot(normal, viewDir);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                fresnel = pow(fresnel, 4.0); // Sharp edge

                // Inner darkness
                vec3 baseColor = vec3(0.0);
                
                // Pulse effect
                float pulse = 0.8 + 0.2 * sin(time * 2.0);
                
                vec3 finalColor = mix(baseColor, glowColor * pulse, fresnel);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- OBJECTS ---

        // 1. The Core (Black Hole Event Horizon)
        const coreGeometry = new THREE.SphereGeometry(CONFIG.coreSize, 64, 64);
        const coreMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                glowColor: { value: new THREE.Color(0xFFA500) } // Orange/Gold glow
            },
            vertexShader: horizonVertexShader,
            fragmentShader: horizonFragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        // We actually want the core to be black in the middle and glow on edges
        // But for the "Simulation", a pure black sphere with a glowing rim behind it is better.
        // Let's stick to a black sphere for the physical blocking, and a slightly larger glowing sphere for the lensing effect.

        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const core = new THREE.Mesh(coreGeometry, blackHoleMat);
        scene.add(core);

        const glowMesh = new THREE.Mesh(
            new THREE.SphereGeometry(CONFIG.coreSize * 1.02, 64, 64),
            coreMaterial
        );
        scene.add(glowMesh);


        // 2. Accretion Disk (Particle System)
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const speeds = [];
        const offsets = [];

        const colorInner = new THREE.Color(CONFIG.colors.accretionInner);
        const colorOuter = new THREE.Color(CONFIG.colors.accretionOuter);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            // Distribution: More density near the center
            // Random radius from coreSize to 15
            // Using logic to bias towards center
            const r = THREE.MathUtils.randFloat(CONFIG.coreSize + 0.5, 12);
            // Flat disk mainly
            const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);

            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const y = (Math.random() - 0.5) * 0.5 * (r / 10); // Thin disk

            positions.push(x, y, z);

            // Color mixed based on radius
            const mixedColor = colorInner.clone().lerp(colorOuter, (r - CONFIG.coreSize) / 8);
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);

            sizes.push(Math.random() * 0.5 + 0.1);
            speeds.push(Math.random() * 0.5 + 0.2);
            offsets.push(Math.random() * Math.PI * 2);
        }

        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        particlesGeometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));
        particlesGeometry.setAttribute('offset', new THREE.Float32BufferAttribute(offsets, 1));

        const diskMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pointTexture: { value: particleTexture }
            },
            vertexShader: diskVertexShader,
            fragmentShader: diskFragmentShader,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            vertexColors: true
        });

        const particleSystem = new THREE.Points(particlesGeometry, diskMaterial);
        scene.add(particleSystem);

        // 3. Starfield Background
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        const starColors = [];
        for (let i = 0; i < 2000; i++) {
            const x = THREE.MathUtils.randFloatSpread(400);
            const y = THREE.MathUtils.randFloatSpread(400);
            const z = THREE.MathUtils.randFloatSpread(400);
            if (Math.abs(x) < 20 && Math.abs(z) < 20) continue;
            starPositions.push(x, y, z);
            const starColor = new THREE.Color().setHSL(Math.random(), 0.2, 0.8 + Math.random() * 0.2);
            starColors.push(starColor.r, starColor.g, starColor.b);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

        const starMaterial = new THREE.PointsMaterial({
            size: 0.7,
            vertexColors: true,
            map: particleTexture,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);



            const elapsedTime = clock.getElapsedTime();

            // 1. Visual Updates
            diskMaterial.uniforms.time.value = elapsedTime;
            coreMaterial.uniforms.time.value = elapsedTime;

            // Rotate starfield slowly
            stars.rotation.y = elapsedTime * 0.05;
            stars.rotation.z = Math.sin(elapsedTime * 0.1) * 0.02;

            // Pulse Bloom
            const pulse = Math.sin(elapsedTime * 2.0) * 0.5 + 0.5; // 0 to 1
            bloomPass.strength = CONFIG.bloomStrength + pulse * 0.5;

            // 2. Simulation Logic (Stats)
            // Intelligence grows exponentially
            const intelligence = Math.pow(1.5, elapsedTime * 0.5);
            let intelligenceDisplay;
            if (intelligence > 1000000) {
                intelligenceDisplay = (intelligence / 1000000).toFixed(2) + " x 10^6";
            } else {
                intelligenceDisplay = intelligence.toFixed(2);
            }

            // Entropy increases linearly then spikes
            const entropy = (elapsedTime * 0.05 + Math.max(0, elapsedTime - 30) * 0.1).toFixed(4);

            // Stability decreases
            let stability = Math.max(0, 100 - (elapsedTime * 0.5));
            // Add some noise to stability
            stability += (Math.random() - 0.5) * 2;
            stability = Math.min(100, Math.max(0, stability));

            // 3. Dynamic Coloring (Heat up the core)
            if (elapsedTime > 20) {
                // Shift glow towards red/white as it gets unstable
                const t = Math.min(1, (elapsedTime - 20) / 60);
                coreMaterial.uniforms.glowColor.value.lerp(new THREE.Color(0xFFFFFF), 0.001);
            }

            // UI Updates
            document.getElementById('entropy').innerText = entropy;
            document.getElementById('density').innerText = intelligenceDisplay + " Yottabytes";
            document.getElementById('stability').innerText = stability.toFixed(2) + "%";

            // Warning colors
            const ui = document.getElementById('ui-layer');
            if (stability < 50) {
                ui.style.color = '#ffaa00';
            }
            if (stability < 20) {
                ui.style.color = '#ff0000';
                if (Math.random() > 0.9) ui.style.opacity = Math.random();
            } else {
                ui.style.opacity = 1;
            }

            controls.update();
            composer.render();

        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading screen
        document.getElementById('loading').style.display = 'none';

        animate();
    </script>
</body>

</html>
